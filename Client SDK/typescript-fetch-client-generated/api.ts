/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * OCS Inventory Rest API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.ocsinventory-ng.tld/ocsapi/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ComputerDetail
 */
export interface ComputerDetail {
    /**
     * 
     * @type {ComputerDetailComputerId}
     * @memberof ComputerDetail
     */
    computerId?: ComputerDetailComputerId;
}
/**
 * 
 * @export
 * @interface ComputerDetailComputerId
 */
export interface ComputerDetailComputerId {
    /**
     * 
     * @type {Array<ComputersListComputerIdBios>}
     * @memberof ComputerDetailComputerId
     */
    bios?: Array<ComputersListComputerIdBios>;
}
/**
 * In this case batteries and bios are inventory sections defined in Map.pm file
 * @export
 * @interface ComputersList
 */
export interface ComputersList {
    /**
     * 
     * @type {ComputersListComputerId}
     * @memberof ComputersList
     */
    computerId?: ComputersListComputerId;
}
/**
 * 
 * @export
 * @interface ComputersListComputerId
 */
export interface ComputersListComputerId {
    /**
     * 
     * @type {Array<ComputersListComputerIdAccountinfo>}
     * @memberof ComputersListComputerId
     */
    accountinfo?: Array<ComputersListComputerIdAccountinfo>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ComputersListComputerId
     */
    batteries?: Array<string>;
    /**
     * 
     * @type {Array<ComputersListComputerIdBios>}
     * @memberof ComputersListComputerId
     */
    bios?: Array<ComputersListComputerIdBios>;
}
/**
 * 
 * @export
 * @interface ComputersListComputerIdAccountinfo
 */
export interface ComputersListComputerIdAccountinfo {
    /**
     * 
     * @type {number}
     * @memberof ComputersListComputerIdAccountinfo
     */
    HARDWARE_ID?: number;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdAccountinfo
     */
    TAG?: string;
}
/**
 * 
 * @export
 * @interface ComputersListComputerIdBios
 */
export interface ComputersListComputerIdBios {
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    ASSETTAG?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    BDATE?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    BMANUFACTURER?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    BVERSION?: string;
    /**
     * 
     * @type {number}
     * @memberof ComputersListComputerIdBios
     */
    HARDWARE_ID?: number;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    MMANUFACTURER?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    MMODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    MSN?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    SMANUFACTURER?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    SMODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    SSN?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputersListComputerIdBios
     */
    TYPE?: string;
}
/**
 * 
 * @export
 */
export type IpdiscoverList = Array<IpdiscoverListInner>
/**
 * 
 * @export
 * @interface IpdiscoverListInner
 */
export interface IpdiscoverListInner {
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverListInner
     */
    NETID?: string;
}
/**
 * 
 * @export
 */
export type IpdiscoverNetdevices = Array<IpdiscoverNetdevicesInner>
/**
 * 
 * @export
 * @interface IpdiscoverNetdevicesInner
 */
export interface IpdiscoverNetdevicesInner {
    /**
     * 
     * @type {Date}
     * @memberof IpdiscoverNetdevicesInner
     */
    DATE?: Date;
    /**
     * 
     * @type {number}
     * @memberof IpdiscoverNetdevicesInner
     */
    HARDWARE_ID?: number;
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverNetdevicesInner
     */
    IP?: string;
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverNetdevicesInner
     */
    MAC?: string;
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverNetdevicesInner
     */
    MASK?: string;
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverNetdevicesInner
     */
    NAME?: string;
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverNetdevicesInner
     */
    NETID?: string;
    /**
     * 
     * @type {string}
     * @memberof IpdiscoverNetdevicesInner
     */
    TAG?: string;
}
/**
 * 
 * @export
 * @interface ListOfID
 */
export interface ListOfID {
    /**
     * 
     * @type {number}
     * @memberof ListOfID
     */
    ID?: number;
}
/**
 * 
 * @export
 */
export type SNMPDetail = Array<SNMPDetailInner>
/**
 * 
 * @export
 * @interface SNMPDetailInner
 */
export interface SNMPDetailInner {
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultAddressIP?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultGateway?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultLocation?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultMacAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultName?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPDetailInner
     */
    defaultUptime?: string;
    /**
     * 
     * @type {number}
     * @memberof SNMPDetailInner
     */
    ID?: number;
    /**
     * 
     * @type {Date}
     * @memberof SNMPDetailInner
     */
    LASTDATE?: Date;
}
/**
 * 
 * @export
 */
export type SNMPType = Array<SNMPTypeInner>
/**
 * 
 * @export
 * @interface SNMPTypeInner
 */
export interface SNMPTypeInner {
    /**
     * 
     * @type {number}
     * @memberof SNMPTypeInner
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof SNMPTypeInner
     */
    TABLE_TYPE_NAME?: string;
    /**
     * 
     * @type {string}
     * @memberof SNMPTypeInner
     */
    TYPE_NAME?: string;
}
/**
 * 
 * @export
 */
export type SoftwaresList = Array<SoftwaresListInner>
/**
 * 
 * @export
 * @interface SoftwaresListInner
 */
export interface SoftwaresListInner {
    /**
     * 
     * @type {string}
     * @memberof SoftwaresListInner
     */
    NAME?: string;
    /**
     * 
     * @type {string}
     * @memberof SoftwaresListInner
     */
    PUBLISHER?: string;
    /**
     * 
     * @type {string}
     * @memberof SoftwaresListInner
     */
    VERSION?: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a computer by its ID
         * @param {number} id ID of the computer in OCS database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computerIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling computerIdGet.');
            }
            const localVarPath = `/computer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sections informations of a specific computer
         * @param {number} id ID of the computer in OCS database
         * @param {string} sections Name of the requested section (i.e -&gt; bios, software, etc..)
         * @param {string} [where] Search on a specific column of the specific section.
         * @param {string} [operator] Search operator (like, not like, &#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;). Mandatory if where parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computerIdSectionsGet(id: number, sections: string, where?: string, operator?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling computerIdSectionsGet.');
            }
            // verify required parameter 'sections' is not null or undefined
            if (sections === null || sections === undefined) {
                throw new RequiredError('sections','Required parameter sections was null or undefined when calling computerIdSectionsGet.');
            }
            const localVarPath = `/computer/{id}/{sections}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"sections"}}`, encodeURIComponent(String(sections)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (operator !== undefined) {
                localVarQueryParameter['operator'] = operator;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of computers with its detail
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersGet(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/computers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a ID list of computers update during the provided timestamp
         * @param {number} timestamp Timestamp of the number of days to count down from the current date. Optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersLastupdateTimestampGet(timestamp: number, options: any = {}): FetchArgs {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling computersLastupdateTimestampGet.');
            }
            const localVarPath = `/computers/lastupdate/{timestamp}`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a ID list of all computers in the OCS database
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersListIDGet(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/computers/listID`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List IPDiscover network list
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipdiscoverGet(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ipdiscover`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of network devices scanned on one network
         * @param {number} netid Start offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipdiscoverNetworkNetidGet(netid: number, options: any = {}): FetchArgs {
            // verify required parameter 'netid' is not null or undefined
            if (netid === null || netid === undefined) {
                throw new RequiredError('netid','Required parameter netid was null or undefined when calling ipdiscoverNetworkNetidGet.');
            }
            const localVarPath = `/ipdiscover/network/{netid}`
                .replace(`{${"netid"}}`, encodeURIComponent(String(netid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get snmp device list of a specific snmp type
         * @param {string} snmpType Name of the snmp type you want to list
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpSnmpTypeGet(snmpType: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'snmpType' is not null or undefined
            if (snmpType === null || snmpType === undefined) {
                throw new RequiredError('snmpType','Required parameter snmpType was null or undefined when calling snmpSnmpTypeGet.');
            }
            const localVarPath = `/snmp/{snmp_type}`
                .replace(`{${"snmp_type"}}`, encodeURIComponent(String(snmpType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a device from a snmp type with its ID
         * @param {string} snmpType Name of the snmp type you want to list
         * @param {number} id Identifiant en base de données de l&#x27;équipement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpSnmpTypeIdGet(snmpType: string, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'snmpType' is not null or undefined
            if (snmpType === null || snmpType === undefined) {
                throw new RequiredError('snmpType','Required parameter snmpType was null or undefined when calling snmpSnmpTypeIdGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling snmpSnmpTypeIdGet.');
            }
            const localVarPath = `/snmp/{snmp_type}/{id}`
                .replace(`{${"snmp_type"}}`, encodeURIComponent(String(snmpType)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a SNMP type list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpsTypeListGet(options: any = {}): FetchArgs {
            const localVarPath = `/snmps/typeList`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get software list from database
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {string} [soft] Name of the software you want to search (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softwaresGet(start?: number, limit?: number, soft?: string, options: any = {}): FetchArgs {
            const localVarPath = `/softwares`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (soft !== undefined) {
                localVarQueryParameter['soft'] = soft;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a computer by its ID
         * @param {number} id ID of the computer in OCS database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computerIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComputersList> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computerIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get sections informations of a specific computer
         * @param {number} id ID of the computer in OCS database
         * @param {string} sections Name of the requested section (i.e -&gt; bios, software, etc..)
         * @param {string} [where] Search on a specific column of the specific section.
         * @param {string} [operator] Search operator (like, not like, &#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;). Mandatory if where parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computerIdSectionsGet(id: number, sections: string, where?: string, operator?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComputerDetail> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computerIdSectionsGet(id, sections, where, operator, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of computers with its detail
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersGet(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputersList>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computersGet(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a ID list of computers update during the provided timestamp
         * @param {number} timestamp Timestamp of the number of days to count down from the current date. Optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersLastupdateTimestampGet(timestamp: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ListOfID>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computersLastupdateTimestampGet(timestamp, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a ID list of all computers in the OCS database
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersListIDGet(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ListOfID>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computersListIDGet(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List IPDiscover network list
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipdiscoverGet(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IpdiscoverList> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ipdiscoverGet(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get list of network devices scanned on one network
         * @param {number} netid Start offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipdiscoverNetworkNetidGet(netid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IpdiscoverNetdevices> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ipdiscoverNetworkNetidGet(netid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get snmp device list of a specific snmp type
         * @param {string} snmpType Name of the snmp type you want to list
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpSnmpTypeGet(snmpType: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SNMPDetail> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).snmpSnmpTypeGet(snmpType, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a device from a snmp type with its ID
         * @param {string} snmpType Name of the snmp type you want to list
         * @param {number} id Identifiant en base de données de l&#x27;équipement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpSnmpTypeIdGet(snmpType: string, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SNMPDetail> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).snmpSnmpTypeIdGet(snmpType, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a SNMP type list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpsTypeListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SNMPType> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).snmpsTypeListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get software list from database
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {string} [soft] Name of the software you want to search (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softwaresGet(start?: number, limit?: number, soft?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SoftwaresList> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).softwaresGet(start, limit, soft, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a computer by its ID
         * @param {number} id ID of the computer in OCS database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computerIdGet(id: number, options?: any) {
            return DefaultApiFp(configuration).computerIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get sections informations of a specific computer
         * @param {number} id ID of the computer in OCS database
         * @param {string} sections Name of the requested section (i.e -&gt; bios, software, etc..)
         * @param {string} [where] Search on a specific column of the specific section.
         * @param {string} [operator] Search operator (like, not like, &#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;). Mandatory if where parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computerIdSectionsGet(id: number, sections: string, where?: string, operator?: string, options?: any) {
            return DefaultApiFp(configuration).computerIdSectionsGet(id, sections, where, operator, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of computers with its detail
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersGet(start?: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).computersGet(start, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a ID list of computers update during the provided timestamp
         * @param {number} timestamp Timestamp of the number of days to count down from the current date. Optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersLastupdateTimestampGet(timestamp: number, options?: any) {
            return DefaultApiFp(configuration).computersLastupdateTimestampGet(timestamp, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a ID list of all computers in the OCS database
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computersListIDGet(start?: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).computersListIDGet(start, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List IPDiscover network list
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipdiscoverGet(start?: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).ipdiscoverGet(start, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get list of network devices scanned on one network
         * @param {number} netid Start offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipdiscoverNetworkNetidGet(netid: number, options?: any) {
            return DefaultApiFp(configuration).ipdiscoverNetworkNetidGet(netid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get snmp device list of a specific snmp type
         * @param {string} snmpType Name of the snmp type you want to list
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpSnmpTypeGet(snmpType: string, start?: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).snmpSnmpTypeGet(snmpType, start, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a device from a snmp type with its ID
         * @param {string} snmpType Name of the snmp type you want to list
         * @param {number} id Identifiant en base de données de l&#x27;équipement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpSnmpTypeIdGet(snmpType: string, id: number, options?: any) {
            return DefaultApiFp(configuration).snmpSnmpTypeIdGet(snmpType, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a SNMP type list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snmpsTypeListGet(options?: any) {
            return DefaultApiFp(configuration).snmpsTypeListGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get software list from database
         * @param {number} [start] Start offset of the query
         * @param {number} [limit] Limit offset of the query
         * @param {string} [soft] Name of the software you want to search (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softwaresGet(start?: number, limit?: number, soft?: string, options?: any) {
            return DefaultApiFp(configuration).softwaresGet(start, limit, soft, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get a computer by its ID
     * @param {number} id ID of the computer in OCS database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computerIdGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).computerIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get sections informations of a specific computer
     * @param {number} id ID of the computer in OCS database
     * @param {string} sections Name of the requested section (i.e -&gt; bios, software, etc..)
     * @param {string} [where] Search on a specific column of the specific section.
     * @param {string} [operator] Search operator (like, not like, &#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;). Mandatory if where parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computerIdSectionsGet(id: number, sections: string, where?: string, operator?: string, options?: any) {
        return DefaultApiFp(this.configuration).computerIdSectionsGet(id, sections, where, operator, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of computers with its detail
     * @param {number} [start] Start offset of the query
     * @param {number} [limit] Limit offset of the query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computersGet(start?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).computersGet(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a ID list of computers update during the provided timestamp
     * @param {number} timestamp Timestamp of the number of days to count down from the current date. Optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computersLastupdateTimestampGet(timestamp: number, options?: any) {
        return DefaultApiFp(this.configuration).computersLastupdateTimestampGet(timestamp, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a ID list of all computers in the OCS database
     * @param {number} [start] Start offset of the query
     * @param {number} [limit] Limit offset of the query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computersListIDGet(start?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).computersListIDGet(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List IPDiscover network list
     * @param {number} [start] Start offset of the query
     * @param {number} [limit] Limit offset of the query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ipdiscoverGet(start?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).ipdiscoverGet(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get list of network devices scanned on one network
     * @param {number} netid Start offset of the query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ipdiscoverNetworkNetidGet(netid: number, options?: any) {
        return DefaultApiFp(this.configuration).ipdiscoverNetworkNetidGet(netid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get snmp device list of a specific snmp type
     * @param {string} snmpType Name of the snmp type you want to list
     * @param {number} [start] Start offset of the query
     * @param {number} [limit] Limit offset of the query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public snmpSnmpTypeGet(snmpType: string, start?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).snmpSnmpTypeGet(snmpType, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a device from a snmp type with its ID
     * @param {string} snmpType Name of the snmp type you want to list
     * @param {number} id Identifiant en base de données de l&#x27;équipement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public snmpSnmpTypeIdGet(snmpType: string, id: number, options?: any) {
        return DefaultApiFp(this.configuration).snmpSnmpTypeIdGet(snmpType, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a SNMP type list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public snmpsTypeListGet(options?: any) {
        return DefaultApiFp(this.configuration).snmpsTypeListGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get software list from database
     * @param {number} [start] Start offset of the query
     * @param {number} [limit] Limit offset of the query
     * @param {string} [soft] Name of the software you want to search (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public softwaresGet(start?: number, limit?: number, soft?: string, options?: any) {
        return DefaultApiFp(this.configuration).softwaresGet(start, limit, soft, options)(this.fetch, this.basePath);
    }

}
